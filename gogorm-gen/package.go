// Copyright 2020 lack
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package goproto_gen

import (
	"fmt"
	"go/ast"
	"os"
	"path/filepath"
	"reflect"
	"strings"

	"github.com/vine-io/gogogen/gogenerator/generator"
	"github.com/vine-io/gogogen/gogenerator/types"
	"github.com/vine-io/gogogen/util/log"
)

func newGormPackage(packagePath, packageName string, generateAll bool, omitFieldTypes map[types.Name]struct{}) *gormPackage {
	pkg := &gormPackage{
		DefaultPackage: generator.DefaultPackage{
			// The protobuf package name (foo.bar.baz)
			PackageName: packageName,
			// A path segment relative to the GOPATH root (foo/bar/baz)
			PackagePath: packagePath,
			HeaderText: []byte(
				`
// This file was autogenerated by gogorm-gen. Do not edit it manually!

`),
			PackageDocumentation: []byte(fmt.Sprintf(
				`// Package %s is an autogenerated protobuf IDL.
`, packageName)),
		},
		GenerateAll:    generateAll,
		OmitFieldTypes: omitFieldTypes,
	}
	pkg.FilterFunc = pkg.filterFunc
	pkg.GeneratorFunc = pkg.generatorFunc
	return pkg
}

// gormPackage contains the protobuf implementation of Package.
type gormPackage struct {
	generator.DefaultPackage

	// If true, this package has been vendored into our source tree and thus can
	// only be generated by changing the vendor tree.
	Vendored bool

	// If true, generate protobuf serializations for all public types.
	// If false, only generate protobuf serializations for structs that
	// request serialization.
	GenerateAll bool

	// A list of types to filter to; if not specified all types will be included.
	FilterTypes map[types.Name]struct{}

	// A list of field types that will be excluded from the output struct
	OmitFieldTypes map[types.Name]struct{}

	// A list of names that this package exports
	LocalNames map[string]struct{}

	// A list of type names in this package that will need marshaller rewriting
	// to remove synthetic protobuf fields.
	OptionalTypeNames map[string]struct{}

	// A list of struct tags to generate onto named struct fields
	StructTags map[string]map[string]string

	// An import tracker for this package
	Imports *ImportTracker
}

func (p *gormPackage) Clean(outputBase string) error {
	for _, s := range []string{p.OutputPath()} {
		if err := os.Remove(filepath.Join(outputBase, s)); err != nil && !os.IsNotExist(err) {
			return err
		}
	}
	return nil
}

func (p *gormPackage) GormTypeName() types.Name {
	return types.Name{
		Name:    p.Path(), // the go path "foo/bar/baz"
		Package: p.Name(), // the protobuf package "foo.bar.baz"
		//Path:    p.ImportPath(), // the path of the import to get the proto
	}
}

func (p *gormPackage) filterFunc(c *generator.Context, t *types.Type) bool {
	switch t.Kind {
	case types.Func, types.Chan:
		return false
	case types.Struct:
		if t.Name.Name == "struct{}" {
			return false
		}
		// +gogo:genproto
		if !extractBoolTagOrDie(tagEnable, t.CommentLines) {
			return false
		}
	case types.Builtin:
		return false
	case types.Alias:
		if !isOptionalAlias(t) {
			return false
		}
	case types.Slice, types.Array, types.Map:
		return false
	case types.Pointer:
		return false
	}
	if _, ok := isFundamentalGormType(t); ok {
		return false
	}
	_, ok := p.FilterTypes[t.Name]
	return ok
}

func (p *gormPackage) HasGoType(name string) bool {
	_, ok := p.LocalNames[name]
	_, ok1 := p.LocalNames[strings.TrimPrefix(name, "XX_")]
	return ok || ok1
}

func (p *gormPackage) OptionalTypeName(name string) bool {
	_, ok := p.OptionalTypeNames[name]
	return ok
}

func (p *gormPackage) ExtractGeneratedType(t *ast.TypeSpec) bool {
	if !p.HasGoType(t.Name.Name) {
		return false
	}

	switch s := t.Type.(type) {
	case *ast.StructType:
		for i, f := range s.Fields.List {
			if len(f.Tag.Value) == 0 {
				continue
			}
			tag := strings.Trim(f.Tag.Value, "`")
			gormTag := reflect.StructTag(tag).Get("gorm")
			if len(gormTag) == 0 {
				continue
			}
			if len(f.Names) > 1 {
				log.Warnf("WARNING: struct %s field %d %s: defined multiple names but single gorm tag", t.Name.Name, i, f.Names[0].Name)
			}
			if p.StructTags == nil {
				p.StructTags = make(map[string]map[string]string)
			}
			name := strings.TrimPrefix(t.Name.Name, "XX_")
			m := p.StructTags[name]
			if m == nil {
				m = make(map[string]string)
				p.StructTags[name] = m
			}

			m[f.Names[0].Name] = tag
		}
	default:
		log.Warnf("WARNING: unexpected Go AST type definition: %#v", t)
	}

	return true
}

func (p *gormPackage) generatorFunc(c *generator.Context) []generator.Generator {
	generators := []generator.Generator{}

	p.Imports.AddType(&types.Type{
		Kind: types.Gorm,
		Name: types.Name{
			Name:    "gorm",
			Package: "gorm",
			Path:    "gorm.io/gorm",
		},
	})
	p.Imports.AddType(&types.Type{
		Kind: types.Gorm,
		Name: types.Name{
			Name:    "clause",
			Package: "clause",
			Path:    "gorm.io/gorm/clause",
		},
	})
	p.Imports.AddType(&types.Type{
		Kind: types.Gorm,
		Name: types.Name{
			Name:    "jsonpatch",
			Package: "jsonpatch",
			Path:    "github.com/evanphx/json-patch/v5",
		},
	})
	p.Imports.AddType(&types.Type{
		Kind: types.Gorm,
		Name: types.Name{
			Name:    "jsonpatch",
			Package: "jsonpatch",
			Path:    "github.com/evanphx/json-patch/v5",
		},
	})
	p.Imports.AddType(&types.Type{
		Kind: types.Gorm,
		Name: types.Name{
			Name:    "json",
			Package: "json",
			Path:    "github.com/json-iterator/go",
		},
	})

	generators = append(generators, &genGormIDL{
		DefaultGen: generator.DefaultGen{
			OptionalName: "gorm_generated",
		},
		localPackage:   types.Name{Package: p.PackageName, Path: p.PackagePath},
		localGoPackage: types.Name{Package: p.PackagePath, Name: p.GoPackageName()},
		imports:        p.Imports,
		generateAll:    p.GenerateAll,
		omitFieldTypes: p.OmitFieldTypes,
	})
	return generators
}

func (p *gormPackage) GoPackageName() string {
	return filepath.Base(p.PackagePath)
}

//func (p *gormPackage) ImportPath() string {
//	return filepath.Join(p.PackagePath, "gorm_generated.proto")
//}

func (p *gormPackage) OutputPath() string {
	return filepath.Join(p.PackagePath, "gorm_generated.go")
}

var (
	_ = generator.Package(&gormPackage{})
)

func tagHeaderTrim(tag string) (string, string) {
	parts := strings.Split(tag, ":")
	if len(parts) > 1 {
		return parts[0], strings.Trim(parts[1], `"`)
	}
	return tag, ""
}
